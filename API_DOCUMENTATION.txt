================================================================================
                    DOCUMENTAZIONE API PAYGLOBE MERCHANT
                          Gestione Store e Terminali
================================================================================

VERSIONE: 1.0
DATA: 2025-11-12
BASE URL: https://api.payglobe.it/merchant/api

================================================================================
1. PANORAMICA GENERALE
================================================================================

L'API PayGlobe Merchant √® un servizio RESTful che permette la gestione completa
dei punti vendita (store) e terminali POS associati ai merchant.

SCOPO PRINCIPALE:
-----------------
- Gestire anagrafiche complete di punti vendita/terminali
- Sincronizzare dati tra sistemi interni ed esterni
- Fornire accesso programmatico alle informazioni dei merchant
- Supportare operazioni CRUD (Create, Read, Update, Delete) complete


COSA GESTISCE:
--------------
Ogni "store" rappresenta un punto vendita/terminale POS con:
  ‚Ä¢ Dati anagrafici (ragione sociale, insegna)
  ‚Ä¢ Ubicazione fisica (indirizzo, citt√†, CAP, provincia)
  ‚Ä¢ Identificativi circuiti pagamento (SIA, SIX, AMEX)
  ‚Ä¢ Modello hardware POS
  ‚Ä¢ Codici business unit
  ‚Ä¢ Codice paese


UTILIZZO TIPICO:
----------------
1. Sistemi di back-office per gestire flotte di terminali
2. Dashboard di amministrazione merchant
3. Integrazioni con sistemi ERP/CRM
4. Sincronizzazione dati multi-piattaforma
5. Report e analisi su base geografica/tipologica


================================================================================
2. AUTENTICAZIONE
================================================================================

TIPO: Basic Authentication (HTTP Basic Auth)

Credenziali:
  Username: moneynet
  Password: demo123

Header richiesto in ogni chiamata:
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

ESEMPIO CURL:
  curl -u moneynet:demo123 https://api.payglobe.it/merchant/api/stores

NOTA SICUREZZA:
  ‚Ä¢ Usa sempre HTTPS per proteggere le credenziali
  ‚Ä¢ Le credenziali vanno codificate in Base64
  ‚Ä¢ Non esporre mai username/password in codice client-side


================================================================================
3. FORMATO DATI
================================================================================

REQUEST:
  Content-Type: application/json

RESPONSE:
  Content-Type: application/json
  Encoding: UTF-8


STRUTTURA OGGETTO STORE:
------------------------

{
  "TerminalID": "string",           // ID univoco terminale (PRIMARY KEY)
  "Ragione_Sociale": "string",      // Ragione sociale azienda
  "Insegna": "string",              // Nome commerciale punto vendita
  "indirizzo": "string",            // Indirizzo completo
  "citta": "string",                // Citt√†
  "cap": "string",                  // Codice Avviamento Postale
  "prov": "string",                 // Sigla provincia (es: MI, RM, NA)
  "sia_pagobancomat": "string|null",// Codice SIA circuito PagoBancomat
  "six": "string|null",             // Codice SIX
  "amex": "string|null",            // Codice American Express
  "Modello_pos": "string",          // Modello hardware (es: SELF2000LET5)
  "country": "string",              // Codice ISO paese (es: IT, FR, DE)
  "bu": "string",                   // Business Unit principale
  "bu1": "string|null",             // Business Unit secondaria 1
  "bu2": "string"                   // Business Unit secondaria 2
}


CAMPI CHIAVE:
-------------
‚Ä¢ TerminalID: OBBLIGATORIO in POST, identifica univocamente il terminale
‚Ä¢ country: Usare codici ISO 3166-1 alpha-2 (IT, FR, DE, ES, etc.)
‚Ä¢ Modello_pos: Identifica il tipo di hardware installato
‚Ä¢ sia_pagobancomat, six, amex: Codici circuiti di pagamento (opzionali)


================================================================================
4. ENDPOINTS DETTAGLIATI
================================================================================


--------------------------------------------------------------------------------
4.1 GET /stores - LISTA STORE (CON PAGINAZIONE)
--------------------------------------------------------------------------------

COSA FA:
  Recupera una lista paginata di tutti gli store presenti nel sistema.
  Permette di navigare grandi dataset in modo efficiente.

QUANDO USARLO:
  ‚Ä¢ Caricare elenchi in dashboard/backoffice
  ‚Ä¢ Sincronizzare database locali
  ‚Ä¢ Generare report su tutti i merchant
  ‚Ä¢ Implementare ricerche/filtri lato client

PARAMETRI QUERY:
  page=N          Numero pagina (default: 1)
  page_size=N     Elementi per pagina (default: 25, max consigliato: 100)

REQUEST:
  GET /stores?page=1&page_size=50
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

RESPONSE 200 OK:
{
  "page": 1,                  // Pagina corrente
  "page_size": 50,            // Dimensione pagina richiesta
  "total": 15652,             // Totale record nel database
  "items": [                  // Array di oggetti store
    {
      "TerminalID": "12996649",
      "Ragione_Sociale": "Ivs Italia Spa",
      ...
    },
    ...
  ]
}

PAGINAZIONE:
  Totale pagine = ceil(total / page_size)
  Esempio: 15652 record / 50 per pagina = 314 pagine totali

  Per ottenere tutte le pagine:
    for (page = 1; page <= totalPages; page++) {
      GET /stores?page={page}&page_size=50
    }

BEST PRACTICES:
  ‚Ä¢ Non usare page_size troppo grande (max 100) per evitare timeout
  ‚Ä¢ Implementare caching lato client per liste frequenti
  ‚Ä¢ Mostrare indicatori di caricamento per UX migliore
  ‚Ä¢ Gestire correttamente navigazione avanti/indietro nelle pagine

ESEMPIO CODICE (PHP):
  <?php
  $page = 1;
  $pageSize = 50;
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL,
    "https://api.payglobe.it/merchant/api/stores?page=$page&page_size=$pageSize");
  curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
  curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

  $response = curl_exec($ch);
  $data = json_decode($response, true);

  echo "Totale store: " . $data['total'] . "\n";
  foreach ($data['items'] as $store) {
    echo "Store: " . $store['Insegna'] . " (ID: " . $store['TerminalID'] . ")\n";
  }
  ?>

ESEMPIO CODICE (JavaScript):
  async function getStores(page = 1, pageSize = 25) {
    const auth = btoa('moneynet:demo123');
    const response = await fetch(
      `https://api.payglobe.it/merchant/api/stores?page=${page}&page_size=${pageSize}`,
      {
        headers: {
          'Authorization': `Basic ${auth}`
        }
      }
    );
    return await response.json();
  }

  const result = await getStores(1, 50);
  console.log(`Trovati ${result.total} store totali`);


--------------------------------------------------------------------------------
4.2 GET /stores/{TerminalID} - DETTAGLIO SINGOLO STORE
--------------------------------------------------------------------------------

COSA FA:
  Recupera i dettagli completi di un singolo store identificato dal suo
  TerminalID univoco.

QUANDO USARLO:
  ‚Ä¢ Visualizzare dettagli completi di un punto vendita
  ‚Ä¢ Verificare esistenza di un terminale
  ‚Ä¢ Caricare dati prima di un aggiornamento
  ‚Ä¢ Validare dati dopo una creazione/modifica

REQUEST:
  GET /stores/12996649
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

RESPONSE 200 OK:
{
  "TerminalID": "12996649",
  "Ragione_Sociale": "Ivs Italia Spa",
  "Insegna": "ACQ. DISTRIB. AUTOMATICO",
  "indirizzo": "V. DELL'ARTIGIANATO 25 -  - BG -",
  "citta": "BG",
  "cap": "",
  "prov": "",
  "sia_pagobancomat": null,
  "six": null,
  "amex": null,
  "Modello_pos": "SELF2000LET5",
  "country": "IT",
  "bu": "---",
  "bu1": null,
  "bu2": "12996649"
}

RESPONSE 404 NOT FOUND (presumibile):
{
  "error": "Store not found"
}

USE CASE ESEMPIO:
  SCENARIO: Form di modifica store

  1. Utente clicca "Modifica" su store con ID 12996649
  2. Sistema chiama GET /stores/12996649
  3. Sistema popola form con dati ricevuti
  4. Utente modifica campi desiderati
  5. Sistema invia PATCH con solo campi modificati

ESEMPIO CODICE (PHP):
  function getStoreById($terminalId) {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL,
      "https://api.payglobe.it/merchant/api/stores/" . $terminalId);
    curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    if ($httpCode == 404) {
      return null; // Store non trovato
    }

    return json_decode($response, true);
  }

  $store = getStoreById('12996649');
  if ($store) {
    echo "Store trovato: " . $store['Insegna'];
  } else {
    echo "Store non trovato";
  }


--------------------------------------------------------------------------------
4.3 POST /stores - CREAZIONE NUOVO STORE
--------------------------------------------------------------------------------

COSA FA:
  Crea un nuovo store/terminale nel sistema con i dati forniti.

QUANDO USARLO:
  ‚Ä¢ Registrazione nuovo punto vendita
  ‚Ä¢ Importazione dati da sistema esterno
  ‚Ä¢ Onboarding nuovi merchant
  ‚Ä¢ Migrazione dati da vecchi sistemi

CAMPO OBBLIGATORIO:
  TerminalID (string) - ID univoco del terminale

REQUEST:
  POST /stores
  Content-Type: application/json
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

  {
    "TerminalID": "99999999",
    "Ragione_Sociale": "Test Store SRL",
    "Insegna": "Negozio Test",
    "indirizzo": "Via Roma 123",
    "citta": "Milano",
    "cap": "20100",
    "prov": "MI",
    "Modello_pos": "SELF2000LET5",
    "country": "IT",
    "bu": "TEST001"
  }

RESPONSE 201 CREATED (presumibile):
  {
    "TerminalID": "99999999",
    "Ragione_Sociale": "Test Store SRL",
    ...
  }

RESPONSE 400 BAD REQUEST:
  {
    "error": "Missing TerminalID"
  }

RESPONSE 409 CONFLICT (presumibile):
  {
    "error": "TerminalID already exists"
  }

VALIDAZIONI CONSIGLIATE LATO CLIENT:
  ‚Ä¢ TerminalID non vuoto e univoco
  ‚Ä¢ TerminalID formato corretto (solo numeri, lunghezza fissa?)
  ‚Ä¢ country in formato ISO (2 caratteri)
  ‚Ä¢ cap formato corretto per il paese
  ‚Ä¢ prov sigla valida (2 caratteri per IT)

WORKFLOW COMPLETO:
  1. Validare dati form utente
  2. Verificare TerminalID non esista (GET /stores/{ID})
  3. Se non esiste, chiamare POST /stores con dati completi
  4. Gestire risposta:
     - 201: Successo, mostrare conferma
     - 400: Errore validazione, mostrare errori
     - 409: ID duplicato, chiedere nuovo ID

ESEMPIO CODICE (PHP):
  function createStore($storeData) {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL,
      "https://api.payglobe.it/merchant/api/stores");
    curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
    curl_setopt($ch, CURLOPT_POST, true);
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($storeData));
    curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    return [
      'success' => $httpCode >= 200 && $httpCode < 300,
      'code' => $httpCode,
      'data' => json_decode($response, true)
    ];
  }

  // Uso:
  $newStore = [
    'TerminalID' => '99999999',
    'Ragione_Sociale' => 'Nuovo Store SRL',
    'Insegna' => 'Store Test',
    'country' => 'IT'
  ];

  $result = createStore($newStore);
  if ($result['success']) {
    echo "Store creato con successo!";
  } else {
    echo "Errore: " . $result['data']['error'];
  }


--------------------------------------------------------------------------------
4.4 PUT /stores/{TerminalID} - AGGIORNAMENTO COMPLETO
--------------------------------------------------------------------------------

COSA FA:
  Sostituisce COMPLETAMENTE tutti i dati di uno store esistente.
  Tutti i campi devono essere forniti, anche quelli non modificati.

QUANDO USARLO:
  ‚Ä¢ Sovrascrittura completa record
  ‚Ä¢ Sincronizzazione da sistema master
  ‚Ä¢ Reset completo dati store

‚ö†Ô∏è ATTENZIONE:
  PUT √® un FULL UPDATE. Campi non inviati vengono impostati a null/default.
  Per aggiornamenti parziali usa PATCH invece.

REQUEST:
  PUT /stores/12996649
  Content-Type: application/json
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

  {
    "TerminalID": "12996649",
    "Ragione_Sociale": "Ivs Italia Spa",
    "Insegna": "NUOVO NOME INSEGNA",
    "indirizzo": "V. DELL'ARTIGIANATO 25 -  - BG -",
    "citta": "BG",
    "cap": "24068",
    "prov": "BG",
    "sia_pagobancomat": null,
    "six": null,
    "amex": null,
    "Modello_pos": "SELF2000LET5",
    "country": "IT",
    "bu": "---",
    "bu1": null,
    "bu2": "12996649"
  }

RESPONSE 200 OK:
  Ritorna l'oggetto store completo aggiornato.

DIFFERENZA PUT vs PATCH:

  PUT (Full Update):
    ‚Ä¢ Richiede TUTTI i campi
    ‚Ä¢ Sostituisce completamente il record
    ‚Ä¢ Campi mancanti = null/default
    ‚Ä¢ Uso: sync completa, replace completo

  PATCH (Partial Update):
    ‚Ä¢ Richiede SOLO campi da modificare
    ‚Ä¢ Mantiene campi non specificati
    ‚Ä¢ Pi√π sicuro per singole modifiche
    ‚Ä¢ Uso: modifica campo specifico

ESEMPIO SBAGLIATO (PUT):
  // ‚ùå SBAGLIATO: Mancano molti campi, verranno persi!
  PUT /stores/12996649
  {
    "Insegna": "Nuovo Nome"
  }
  // Risultato: tutti gli altri campi diventano null!

ESEMPIO CORRETTO (PUT):
  // ‚úÖ CORRETTO: Tutti i campi presenti
  1. GET /stores/12996649  -> recupera dati completi
  2. Modifica campo desiderato nell'oggetto
  3. PUT /stores/12996649 con oggetto completo


--------------------------------------------------------------------------------
4.5 PATCH /stores/{TerminalID} - AGGIORNAMENTO PARZIALE
--------------------------------------------------------------------------------

COSA FA:
  Aggiorna solo i campi specificati di uno store, lasciando invariati
  tutti gli altri campi non menzionati.

QUANDO USARLO:
  ‚Ä¢ Modifica di pochi campi specifici (es: solo Insegna)
  ‚Ä¢ Aggiornamento dati parziali da form
  ‚Ä¢ Correzione errori su campi specifici
  ‚Ä¢ Update incrementali

‚úÖ CONSIGLIATO: Usa PATCH nella maggior parte dei casi di aggiornamento!

REQUEST:
  PATCH /stores/12996649
  Content-Type: application/json
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

  {
    "Insegna": "NOME AGGIORNATO",
    "cap": "24068"
  }

RESPONSE 200 OK:
  {
    "TerminalID": "12996649",
    "Ragione_Sociale": "Ivs Italia Spa",        // ‚Üê Non modificato
    "Insegna": "NOME AGGIORNATO",               // ‚Üê Modificato
    "indirizzo": "V. DELL'ARTIGIANATO 25...",   // ‚Üê Non modificato
    "citta": "BG",                              // ‚Üê Non modificato
    "cap": "24068",                             // ‚Üê Modificato
    "prov": "",                                 // ‚Üê Non modificato
    ...tutti gli altri campi invariati
  }

VANTAGGI PATCH:
  ‚Ä¢ Pi√π sicuro: non rischi di perdere dati
  ‚Ä¢ Pi√π efficiente: invii solo dati necessari
  ‚Ä¢ Pi√π semplice: non serve GET preventivo
  ‚Ä¢ Meno errori: meno dati = meno possibilit√† di errore

CASI D'USO COMUNI:

  1. Aggiornare solo l'insegna:
     PATCH /stores/12996649 {"Insegna": "Nuovo Nome"}

  2. Aggiornare indirizzo completo:
     PATCH /stores/12996649 {
       "indirizzo": "Via Nuova 456",
       "citta": "Roma",
       "cap": "00100",
       "prov": "RM"
     }

  3. Aggiungere codici circuiti:
     PATCH /stores/12996649 {
       "sia_pagobancomat": "12345",
       "six": "67890"
     }

  4. Cambiare modello POS:
     PATCH /stores/12996649 {"Modello_pos": "SELF3000LET5"}

ESEMPIO CODICE (PHP):
  function updateStoreField($terminalId, $field, $value) {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL,
      "https://api.payglobe.it/merchant/api/stores/" . $terminalId);
    curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "PATCH");
    curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode([$field => $value]));
    curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

    $response = curl_exec($ch);
    return json_decode($response, true);
  }

  // Aggiorna solo l'insegna
  $updated = updateStoreField('12996649', 'Insegna', 'Nuovo Nome');
  echo "Insegna aggiornata: " . $updated['Insegna'];


--------------------------------------------------------------------------------
4.6 DELETE /stores/{TerminalID} - ELIMINAZIONE STORE
--------------------------------------------------------------------------------

COSA FA:
  Elimina permanentemente uno store dal sistema.

‚ö†Ô∏è ATTENZIONE: Operazione irreversibile!

QUANDO USARLO:
  ‚Ä¢ Dismissione terminale
  ‚Ä¢ Pulizia dati duplicati
  ‚Ä¢ Chiusura punto vendita
  ‚Ä¢ Correzione errori di importazione

REQUEST:
  DELETE /stores/12996649
  Authorization: Basic bW9uZXluZXQ6ZGVtbzEyMw==

RESPONSE 204 NO CONTENT (presumibile):
  Nessun body, solo header HTTP 204

RESPONSE 404 NOT FOUND (presumibile):
  {
    "error": "Store not found"
  }

BEST PRACTICES SICUREZZA:
  1. ‚ö†Ô∏è Richiedere sempre conferma utente
  2. üìã Fare backup/log prima di eliminare
  3. üîç Verificare dipendenze (transazioni, report, etc.)
  4. üö´ Implementare soft-delete invece di hard-delete se possibile
  5. üë• Limitare permessi DELETE a utenti autorizzati

WORKFLOW CONSIGLIATO:
  1. Mostrare dialog conferma: "Sei sicuro di voler eliminare lo store X?"
  2. (Opzionale) Verificare store non abbia transazioni attive
  3. (Opzionale) Archiviare dati store prima di eliminare
  4. Chiamare DELETE /stores/{ID}
  5. Gestire risposta e aggiornare UI

ESEMPIO CODICE (PHP):
  function deleteStore($terminalId) {
    // 1. Log operazione per audit
    error_log("Eliminazione store: $terminalId");

    // 2. Backup dati (opzionale)
    $store = getStoreById($terminalId);
    if ($store) {
      file_put_contents(
        "deleted_stores.log",
        date('Y-m-d H:i:s') . " - " . json_encode($store) . "\n",
        FILE_APPEND
      );
    }

    // 3. Eliminazione
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL,
      "https://api.payglobe.it/merchant/api/stores/" . $terminalId);
    curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "DELETE");
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

    return $httpCode == 204 || $httpCode == 200;
  }

  // Uso con conferma
  if (isset($_POST['confirm_delete']) && $_POST['confirm_delete'] == 'yes') {
    $success = deleteStore($_POST['terminal_id']);
    if ($success) {
      echo "Store eliminato con successo";
    } else {
      echo "Errore durante eliminazione";
    }
  }


================================================================================
5. GESTIONE ERRORI
================================================================================

CODICI HTTP STANDARD:

  200 OK
    ‚Ä¢ Richiesta completata con successo (GET, PUT, PATCH)
    ‚Ä¢ Body contiene i dati richiesti/aggiornati

  201 CREATED
    ‚Ä¢ Risorsa creata con successo (POST)
    ‚Ä¢ Body contiene la nuova risorsa creata

  204 NO CONTENT
    ‚Ä¢ Operazione completata senza dati di ritorno (DELETE, OPTIONS)
    ‚Ä¢ Body vuoto

  400 BAD REQUEST
    ‚Ä¢ Errore nei parametri della richiesta
    ‚Ä¢ Body contiene dettagli errore: {"error": "descrizione"}
    ‚Ä¢ Esempi: campo obbligatorio mancante, formato JSON invalido

  401 UNAUTHORIZED
    ‚Ä¢ Autenticazione fallita o mancante
    ‚Ä¢ Credenziali errate o header Authorization assente

  404 NOT FOUND
    ‚Ä¢ Risorsa non trovata
    ‚Ä¢ TerminalID inesistente

  409 CONFLICT (presumibile)
    ‚Ä¢ Conflitto con stato corrente
    ‚Ä¢ Es: tentativo creazione store con TerminalID gi√† esistente

  500 INTERNAL SERVER ERROR
    ‚Ä¢ Errore interno del server
    ‚Ä¢ Contattare supporto tecnico


GESTIONE ERRORI - BEST PRACTICES:

1. CATTURA SEMPRE GLI ERRORI:
   try {
     $response = callApi();
   } catch (Exception $e) {
     logError($e);
     showUserFriendlyMessage();
   }

2. VERIFICA HTTP STATUS CODE:
   if ($httpCode >= 400) {
     handleError($httpCode, $responseBody);
   }

3. MOSTRA MESSAGGI USER-FRIENDLY:
   ‚ùå "Error 400: Missing TerminalID"
   ‚úÖ "Il codice terminale √® obbligatorio"

4. IMPLEMENTA RETRY LOGIC:
   Per errori 500/503, ritenta dopo qualche secondo (max 3 tentativi)

5. LOG DETTAGLIATI:
   Salva sempre: timestamp, endpoint, parametri, risposta, errore


ESEMPIO GESTIONE ERRORI COMPLETA (PHP):

function callApiSafe($method, $endpoint, $data = null) {
  $maxRetries = 3;
  $retryDelay = 1; // secondi

  for ($attempt = 1; $attempt <= $maxRetries; $attempt++) {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, "https://api.payglobe.it/merchant/api" . $endpoint);
    curl_setopt($ch, CURLOPT_USERPWD, "moneynet:demo123");
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);

    if ($data) {
      curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
      curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
    }

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $error = curl_error($ch);
    curl_close($ch);

    // Log chiamata
    error_log(sprintf(
      "[API] %s %s - Status: %d - Attempt: %d/%d",
      $method, $endpoint, $httpCode, $attempt, $maxRetries
    ));

    // Successo
    if ($httpCode >= 200 && $httpCode < 300) {
      return [
        'success' => true,
        'code' => $httpCode,
        'data' => json_decode($response, true)
      ];
    }

    // Errori client (4xx) - non ritentare
    if ($httpCode >= 400 && $httpCode < 500) {
      return [
        'success' => false,
        'code' => $httpCode,
        'error' => json_decode($response, true)['error'] ?? 'Unknown error',
        'retriable' => false
      ];
    }

    // Errori server (5xx) - ritenta
    if ($httpCode >= 500 || $error) {
      if ($attempt < $maxRetries) {
        sleep($retryDelay * $attempt); // Backoff esponenziale
        continue;
      }

      return [
        'success' => false,
        'code' => $httpCode,
        'error' => 'Server error after ' . $maxRetries . ' attempts',
        'retriable' => true
      ];
    }
  }
}

// Uso:
$result = callApiSafe('PATCH', '/stores/12996649', ['Insegna' => 'Test']);

if ($result['success']) {
  echo "Operazione completata!";
} else {
  if ($result['retriable']) {
    echo "Errore temporaneo, riprova pi√π tardi";
  } else {
    echo "Errore: " . $result['error'];
  }
}


================================================================================
6. CASI D'USO COMPLETI
================================================================================

--------------------------------------------------------------------------------
CASO 1: SINCRONIZZAZIONE COMPLETA DATABASE
--------------------------------------------------------------------------------

SCENARIO:
  Hai un database locale che deve essere sincronizzato quotidianamente con
  l'API PayGlobe per avere sempre dati aggiornati.

SOLUZIONE:

<?php
function syncAllStores() {
  $page = 1;
  $pageSize = 100;
  $totalSynced = 0;

  do {
    // Recupera pagina corrente
    $result = callApiSafe('GET', "/stores?page=$page&page_size=$pageSize");

    if (!$result['success']) {
      error_log("Errore sync pagina $page");
      break;
    }

    $data = $result['data'];

    // Processa ogni store
    foreach ($data['items'] as $store) {
      // Inserisci o aggiorna in DB locale
      $stmt = $pdo->prepare("
        INSERT INTO stores (terminal_id, ragione_sociale, insegna, ...)
        VALUES (:tid, :rs, :ins, ...)
        ON DUPLICATE KEY UPDATE
          ragione_sociale = :rs,
          insegna = :ins,
          ...
      ");

      $stmt->execute([
        'tid' => $store['TerminalID'],
        'rs' => $store['Ragione_Sociale'],
        'ins' => $store['Insegna'],
        ...
      ]);

      $totalSynced++;
    }

    echo "Pagina $page/$totalPages sincronizzata\n";
    $page++;

  } while ($page * $pageSize <= $data['total']);

  echo "Sincronizzazione completata: $totalSynced store aggiornati\n";
}

// Esegui sync (es: tramite cron giornaliero)
syncAllStores();
?>


--------------------------------------------------------------------------------
CASO 2: DASHBOARD CON RICERCA E FILTRI
--------------------------------------------------------------------------------

SCENARIO:
  Creare una dashboard web che permetta di cercare store per nome, citt√†,
  provincia con paginazione.

SOLUZIONE:

// Backend API (es: search_stores.php)
<?php
// Parametri ricerca
$searchTerm = $_GET['search'] ?? '';
$city = $_GET['city'] ?? '';
$page = (int)($_GET['page'] ?? 1);

// Recupera tutti gli store (o implementa cache locale)
$allStores = getAllStoresFromLocalCache(); // Usa DB locale per performance

// Filtra lato server
$filtered = array_filter($allStores, function($store) use ($searchTerm, $city) {
  $matchSearch = empty($searchTerm) ||
    stripos($store['Insegna'], $searchTerm) !== false ||
    stripos($store['Ragione_Sociale'], $searchTerm) !== false;

  $matchCity = empty($city) ||
    stripos($store['citta'], $city) !== false;

  return $matchSearch && $matchCity;
});

// Pagina risultati
$pageSize = 25;
$offset = ($page - 1) * $pageSize;
$paginatedResults = array_slice($filtered, $offset, $pageSize);

echo json_encode([
  'results' => $paginatedResults,
  'total' => count($filtered),
  'page' => $page,
  'totalPages' => ceil(count($filtered) / $pageSize)
]);
?>

// Frontend (JavaScript)
<script>
async function searchStores(page = 1) {
  const search = document.getElementById('search').value;
  const city = document.getElementById('city').value;

  const response = await fetch(
    `/api/search_stores.php?search=${search}&city=${city}&page=${page}`
  );
  const data = await response.json();

  // Renderizza risultati
  const tbody = document.getElementById('storesTable');
  tbody.innerHTML = data.results.map(store => `
    <tr>
      <td>${store.TerminalID}</td>
      <td>${store.Insegna}</td>
      <td>${store.citta}</td>
      <td>
        <button onclick="editStore('${store.TerminalID}')">Modifica</button>
        <button onclick="deleteStore('${store.TerminalID}')">Elimina</button>
      </td>
    </tr>
  `).join('');

  // Renderizza paginazione
  renderPagination(data.page, data.totalPages);
}

function renderPagination(currentPage, totalPages) {
  const paginationDiv = document.getElementById('pagination');
  let html = '';

  for (let i = 1; i <= totalPages; i++) {
    const active = i === currentPage ? 'active' : '';
    html += `<button class="${active}" onclick="searchStores(${i})">${i}</button>`;
  }

  paginationDiv.innerHTML = html;
}
</script>


--------------------------------------------------------------------------------
CASO 3: FORM DI MODIFICA STORE
--------------------------------------------------------------------------------

SCENARIO:
  Form web per modificare i dati di uno store esistente.

SOLUZIONE:

// 1. Caricamento dati iniziali (edit_store.php?id=12996649)
<?php
$terminalId = $_GET['id'];
$result = callApiSafe('GET', "/stores/$terminalId");

if (!$result['success']) {
  die("Store non trovato");
}

$store = $result['data'];
?>

<!-- Form HTML -->
<form id="editStoreForm">
  <input type="hidden" name="terminal_id" value="<?= $store['TerminalID'] ?>">

  <label>Ragione Sociale:</label>
  <input type="text" name="ragione_sociale" value="<?= $store['Ragione_Sociale'] ?>">

  <label>Insegna:</label>
  <input type="text" name="insegna" value="<?= $store['Insegna'] ?>" required>

  <label>Indirizzo:</label>
  <input type="text" name="indirizzo" value="<?= $store['indirizzo'] ?>">

  <label>Citt√†:</label>
  <input type="text" name="citta" value="<?= $store['citta'] ?>">

  <label>CAP:</label>
  <input type="text" name="cap" value="<?= $store['cap'] ?>">

  <label>Provincia:</label>
  <input type="text" name="prov" value="<?= $store['prov'] ?>" maxlength="2">

  <button type="submit">Salva Modifiche</button>
</form>

<script>
document.getElementById('editStoreForm').addEventListener('submit', async (e) => {
  e.preventDefault();

  const formData = new FormData(e.target);
  const terminalId = formData.get('terminal_id');

  // Prepara solo campi modificati (per PATCH)
  const updates = {
    Ragione_Sociale: formData.get('ragione_sociale'),
    Insegna: formData.get('insegna'),
    indirizzo: formData.get('indirizzo'),
    citta: formData.get('citta'),
    cap: formData.get('cap'),
    prov: formData.get('prov')
  };

  // Invia PATCH
  const response = await fetch(`/api/update_store.php`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({terminal_id: terminalId, updates: updates})
  });

  const result = await response.json();

  if (result.success) {
    alert('Store aggiornato con successo!');
    window.location.href = '/stores';
  } else {
    alert('Errore: ' + result.error);
  }
});
</script>

// Backend (update_store.php)
<?php
$data = json_decode(file_get_contents('php://input'), true);
$terminalId = $data['terminal_id'];
$updates = $data['updates'];

$result = callApiSafe('PATCH', "/stores/$terminalId", $updates);

echo json_encode($result);
?>


--------------------------------------------------------------------------------
CASO 4: IMPORT MASSIVO DA CSV
--------------------------------------------------------------------------------

SCENARIO:
  Importare centinaia di store da file CSV aziendale.

SOLUZIONE:

<?php
function importStoresFromCsv($csvFilePath) {
  $file = fopen($csvFilePath, 'r');
  $header = fgetcsv($file); // Prima riga = intestazioni

  $stats = [
    'total' => 0,
    'created' => 0,
    'updated' => 0,
    'errors' => 0
  ];

  while (($row = fgetcsv($file)) !== false) {
    $stats['total']++;

    // Mappa CSV -> API fields
    $store = [
      'TerminalID' => $row[0],
      'Ragione_Sociale' => $row[1],
      'Insegna' => $row[2],
      'indirizzo' => $row[3],
      'citta' => $row[4],
      'cap' => $row[5],
      'prov' => $row[6],
      'country' => $row[7] ?? 'IT',
      'Modello_pos' => $row[8] ?? '',
    ];

    // Verifica se esiste
    $existing = callApiSafe('GET', "/stores/{$store['TerminalID']}");

    if ($existing['success']) {
      // Store esiste -> aggiorna
      $result = callApiSafe('PATCH', "/stores/{$store['TerminalID']}", $store);
      if ($result['success']) {
        $stats['updated']++;
      } else {
        $stats['errors']++;
        error_log("Errore update {$store['TerminalID']}: " . $result['error']);
      }
    } else {
      // Store non esiste -> crea
      $result = callApiSafe('POST', "/stores", $store);
      if ($result['success']) {
        $stats['created']++;
      } else {
        $stats['errors']++;
        error_log("Errore create {$store['TerminalID']}: " . $result['error']);
      }
    }

    // Progress ogni 10 record
    if ($stats['total'] % 10 == 0) {
      echo "Processati {$stats['total']} record...\n";
    }

    // Rate limiting (evita sovraccarico server)
    usleep(100000); // 0.1 secondi tra richieste
  }

  fclose($file);

  echo "\n=== Import Completato ===\n";
  echo "Totale: {$stats['total']}\n";
  echo "Creati: {$stats['created']}\n";
  echo "Aggiornati: {$stats['updated']}\n";
  echo "Errori: {$stats['errors']}\n";

  return $stats;
}

// Esegui import
importStoresFromCsv('stores_import.csv');
?>


--------------------------------------------------------------------------------
CASO 5: EXPORT DATI IN EXCEL/CSV
--------------------------------------------------------------------------------

SCENARIO:
  Esportare tutti gli store in formato Excel per analisi offline.

SOLUZIONE:

<?php
require 'vendor/autoload.php'; // PhpSpreadsheet
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;

function exportStoresToExcel($outputFile = 'stores_export.xlsx') {
  $spreadsheet = new Spreadsheet();
  $sheet = $spreadsheet->getActiveSheet();

  // Header
  $headers = [
    'Terminal ID', 'Ragione Sociale', 'Insegna', 'Indirizzo',
    'Citt√†', 'CAP', 'Provincia', 'Modello POS', 'Paese', 'BU'
  ];
  $sheet->fromArray($headers, null, 'A1');

  // Recupera tutti gli store
  $page = 1;
  $pageSize = 100;
  $row = 2; // Riga Excel (dopo header)

  do {
    $result = callApiSafe('GET', "/stores?page=$page&page_size=$pageSize");

    if (!$result['success']) {
      break;
    }

    $data = $result['data'];

    foreach ($data['items'] as $store) {
      $sheet->fromArray([
        $store['TerminalID'],
        $store['Ragione_Sociale'],
        $store['Insegna'],
        $store['indirizzo'],
        $store['citta'],
        $store['cap'],
        $store['prov'],
        $store['Modello_pos'],
        $store['country'],
        $store['bu']
      ], null, "A$row");

      $row++;
    }

    echo "Esportate " . ($page * $pageSize) . " righe...\n";
    $page++;

  } while ($page * $pageSize <= $data['total']);

  // Salva file
  $writer = new Xlsx($spreadsheet);
  $writer->save($outputFile);

  echo "Export completato: $outputFile\n";
  echo "Totale righe: " . ($row - 2) . "\n";
}

exportStoresToExcel();
?>


================================================================================
7. PERFORMANCE E OTTIMIZZAZIONE
================================================================================

BEST PRACTICES:

1. CACHING
   ‚Ä¢ Cache locale per liste frequenti (es: Redis, Memcached)
   ‚Ä¢ TTL: 1-24 ore a seconda della frequenza di aggiornamento
   ‚Ä¢ Invalida cache dopo operazioni POST/PUT/PATCH/DELETE

2. PAGINAZIONE EFFICIENTE
   ‚Ä¢ Non recuperare tutti i record se non necessario
   ‚Ä¢ Usa page_size appropriato (25-100 record)
   ‚Ä¢ Implementa infinite scroll invece di "carica tutto"

3. BATCH OPERATIONS
   ‚Ä¢ Raggruppa operazioni simili
   ‚Ä¢ Implementa rate limiting (es: max 10 req/sec)
   ‚Ä¢ Usa sleep() tra richieste in batch per evitare sovraccarico

4. DATABASE LOCALE
   ‚Ä¢ Mantieni copia locale per query complesse
   ‚Ä¢ Sincronizza periodicamente (es: ogni notte)
   ‚Ä¢ Usa API solo per operazioni real-time

5. COMPRESSIONE
   ‚Ä¢ Abilita gzip nelle richieste HTTP
   ‚Ä¢ Riduci payload dove possibile

6. MONITORAGGIO
   ‚Ä¢ Log tempi di risposta API
   ‚Ä¢ Alert se latenza > soglia
   ‚Ä¢ Dashboard con metriche API


ESEMPIO IMPLEMENTAZIONE CACHE (PHP + Redis):

<?php
$redis = new Redis();
$redis->connect('127.0.0.1', 6379);

function getStoreWithCache($terminalId) {
  global $redis;

  // Controlla cache
  $cacheKey = "store:$terminalId";
  $cached = $redis->get($cacheKey);

  if ($cached !== false) {
    return json_decode($cached, true);
  }

  // Cache miss -> chiama API
  $result = callApiSafe('GET', "/stores/$terminalId");

  if ($result['success']) {
    // Salva in cache (TTL: 1 ora)
    $redis->setex($cacheKey, 3600, json_encode($result['data']));
    return $result['data'];
  }

  return null;
}

function invalidateStoreCache($terminalId) {
  global $redis;
  $redis->del("store:$terminalId");
}

// Uso:
$store = getStoreWithCache('12996649'); // Prima chiamata: API
$store = getStoreWithCache('12996649'); // Seconda chiamata: cache (veloce!)

// Dopo update
callApiSafe('PATCH', '/stores/12996649', ['Insegna' => 'Nuovo']);
invalidateStoreCache('12996649'); // Invalida cache
?>


================================================================================
8. SICUREZZA
================================================================================

CHECKLIST SICUREZZA:

‚òë AUTENTICAZIONE
  ‚Ä¢ Non esporre credenziali in frontend/JavaScript
  ‚Ä¢ Usa proxy server-side per chiamate API
  ‚Ä¢ Ruota periodicamente password
  ‚Ä¢ Non loggare password nei file di log

‚òë AUTORIZZAZIONE
  ‚Ä¢ Implementa controlli accesso lato backend
  ‚Ä¢ Verifica permessi utente prima di chiamare API
  ‚Ä¢ Limita operazioni DELETE a admin

‚òë VALIDAZIONE INPUT
  ‚Ä¢ Valida SEMPRE input utente prima di inviare ad API
  ‚Ä¢ Sanitizza dati per prevenire injection
  ‚Ä¢ Usa prepared statements per query DB locali

‚òë HTTPS
  ‚Ä¢ Usa sempre HTTPS in produzione
  ‚Ä¢ Non disabilitare verifica certificati (curl -k solo in dev!)

‚òë RATE LIMITING
  ‚Ä¢ Implementa throttling per prevenire abuse
  ‚Ä¢ Max X richieste per IP/utente per minuto

‚òë LOGGING & AUDIT
  ‚Ä¢ Logga tutte le operazioni critiche (DELETE, modif massivi)
  ‚Ä¢ Include: timestamp, user, azione, risultato
  ‚Ä¢ Proteggi log da accessi non autorizzati

‚òë ERROR HANDLING
  ‚Ä¢ Non esporre dettagli tecnici a utenti finali
  ‚Ä¢ Log errori lato server, mostra messaggi generici a utenti


ESEMPIO PROXY SICURO (PHP):

<?php
// api_proxy.php - Proxy sicuro per chiamate API

session_start();

// 1. Verifica autenticazione utente
if (!isset($_SESSION['user_id'])) {
  http_response_code(401);
  die(json_encode(['error' => 'Unauthorized']));
}

// 2. Verifica permessi
$user = getUserById($_SESSION['user_id']);
$requestedAction = $_SERVER['REQUEST_METHOD'];
$endpoint = $_GET['endpoint'] ?? '';

// Blocca DELETE se non admin
if ($requestedAction === 'DELETE' && !$user['is_admin']) {
  http_response_code(403);
  die(json_encode(['error' => 'Forbidden']));
}

// 3. Rate limiting
$rateLimitKey = "ratelimit:{$_SESSION['user_id']}";
$requestCount = $redis->incr($rateLimitKey);
if ($requestCount == 1) {
  $redis->expire($rateLimitKey, 60); // 1 minuto
}
if ($requestCount > 30) { // Max 30 req/min
  http_response_code(429);
  die(json_encode(['error' => 'Too many requests']));
}

// 4. Sanitizza input
$data = json_decode(file_get_contents('php://input'), true);
if ($data) {
  $data = array_map('htmlspecialchars', $data);
}

// 5. Chiama API (credenziali sicure lato server)
$result = callApiSafe($requestedAction, $endpoint, $data);

// 6. Audit log
logAuditEvent([
  'user_id' => $_SESSION['user_id'],
  'action' => $requestedAction,
  'endpoint' => $endpoint,
  'success' => $result['success'],
  'ip' => $_SERVER['REMOTE_ADDR']
]);

// 7. Ritorna risposta
http_response_code($result['code'] ?? 200);
echo json_encode($result);
?>


================================================================================
9. TESTING
================================================================================

TEST ESSENZIALI DA ESEGUIRE:

1. TEST CONNETTIVIT√Ä
   curl -u moneynet:demo123 https://api.payglobe.it/merchant/api/stores

2. TEST PAGINAZIONE
   Verifica page=1, ultima pagina, pagina oltre limite

3. TEST CRUD COMPLETO
   a) POST nuovo store
   b) GET store creato
   c) PATCH modifica campo
   d) GET verifica modifica
   e) DELETE store
   f) GET verifica cancellazione (404)

4. TEST ERRORI
   ‚Ä¢ 400: POST senza TerminalID
   ‚Ä¢ 404: GET store inesistente
   ‚Ä¢ 401: Richiesta senza auth

5. TEST EDGE CASES
   ‚Ä¢ Caratteri speciali in campi testo
   ‚Ä¢ Campi null vs stringa vuota
   ‚Ä¢ Lunghezza massima campi
   ‚Ä¢ TerminalID duplicato

6. TEST PERFORMANCE
   ‚Ä¢ Tempo risposta GET lista
   ‚Ä¢ Tempo risposta GET singolo
   ‚Ä¢ Stress test (molte richieste consecutive)


SCRIPT TEST AUTOMATICO (PHP):

<?php
function runApiTests() {
  echo "=== Test Suite API PayGlobe ===\n\n";

  // Test 1: Connettivit√†
  echo "Test 1: Connettivit√†...\n";
  $result = callApiSafe('GET', '/stores?page=1&page_size=1');
  assert($result['success'] === true, "Connessione fallita");
  echo "‚úì Connessione OK\n\n";

  // Test 2: Creazione store
  echo "Test 2: Creazione store...\n";
  $testStore = [
    'TerminalID' => 'TEST' . time(),
    'Ragione_Sociale' => 'Test SRL',
    'Insegna' => 'Test Store',
    'country' => 'IT'
  ];
  $result = callApiSafe('POST', '/stores', $testStore);
  assert($result['success'] === true, "Creazione fallita");
  $createdId = $testStore['TerminalID'];
  echo "‚úì Store creato: $createdId\n\n";

  // Test 3: Lettura store
  echo "Test 3: Lettura store...\n";
  $result = callApiSafe('GET', "/stores/$createdId");
  assert($result['success'] === true, "Lettura fallita");
  assert($result['data']['TerminalID'] === $createdId, "ID mismatch");
  echo "‚úì Store letto correttamente\n\n";

  // Test 4: Aggiornamento PATCH
  echo "Test 4: Aggiornamento PATCH...\n";
  $result = callApiSafe('PATCH', "/stores/$createdId", ['Insegna' => 'Store Modificato']);
  assert($result['success'] === true, "Update fallito");
  assert($result['data']['Insegna'] === 'Store Modificato', "Update non applicato");
  echo "‚úì Store aggiornato\n\n";

  // Test 5: Eliminazione
  echo "Test 5: Eliminazione...\n";
  $result = callApiSafe('DELETE', "/stores/$createdId");
  assert($result['success'] === true, "Eliminazione fallita");
  echo "‚úì Store eliminato\n\n";

  // Test 6: Verifica eliminazione
  echo "Test 6: Verifica eliminazione...\n";
  $result = callApiSafe('GET', "/stores/$createdId");
  assert($result['code'] === 404, "Store ancora presente");
  echo "‚úì Store non pi√π presente (404)\n\n";

  // Test 7: Errore 400
  echo "Test 7: Gestione errore 400...\n";
  $result = callApiSafe('POST', '/stores', []); // Senza TerminalID
  assert($result['code'] === 400, "Dovrebbe ritornare 400");
  echo "‚úì Errore 400 gestito correttamente\n\n";

  echo "=== Tutti i test completati con successo! ===\n";
}

runApiTests();
?>


================================================================================
10. TROUBLESHOOTING
================================================================================

PROBLEMI COMUNI E SOLUZIONI:

PROBLEMA: Errore SSL/Certificate
SINTOMO: "SSL certificate problem" o "CRYPT_E_NO_REVOCATION_CHECK"
SOLUZIONE:
  ‚Ä¢ Dev: curl -k per saltare verifica (solo dev!)
  ‚Ä¢ Prod: Installare certificato CA corretto
  ‚Ä¢ PHP: curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); (solo dev!)

PROBLEMA: 401 Unauthorized
SINTOMO: Tutte le richieste ritornano 401
SOLUZIONE:
  ‚Ä¢ Verifica username/password corretti
  ‚Ä¢ Verifica header Authorization presente
  ‚Ä¢ Verifica encoding Base64: echo -n "moneynet:demo123" | base64

PROBLEMA: Timeout
SINTOMO: Richieste molto lente o timeout
SOLUZIONE:
  ‚Ä¢ Aumenta timeout: curl_setopt($ch, CURLOPT_TIMEOUT, 30);
  ‚Ä¢ Controlla connettivit√† rete
  ‚Ä¢ Riduci page_size per liste grandi
  ‚Ä¢ Usa cache locale

PROBLEMA: 500 Internal Server Error
SINTOMO: Errore 500 su richieste valide
SOLUZIONE:
  ‚Ä¢ Verifica formato JSON corretto
  ‚Ä¢ Controlla log server se accessibili
  ‚Ä¢ Ritenta dopo qualche minuto
  ‚Ä¢ Contatta supporto tecnico

PROBLEMA: Dati non aggiornati
SINTOMO: Modifiche non visibili immediatamente
SOLUZIONE:
  ‚Ä¢ Invalida cache locale
  ‚Ä¢ Attendi propagazione (pochi secondi)
  ‚Ä¢ Verifica risposta API per conferma update

PROBLEMA: TerminalID duplicato
SINTOMO: Errore 409 su POST
SOLUZIONE:
  ‚Ä¢ Verifica TerminalID non gi√† esistente (GET)
  ‚Ä¢ Usa ID univoci (timestamp, UUID, etc.)
  ‚Ä¢ Implementa logica update se esiste


DEBUG CHECKLIST:

‚ñ° Verificare credenziali Basic Auth
‚ñ° Verificare endpoint URL corretto
‚ñ° Verificare formato JSON valido (usa jsonlint.com)
‚ñ° Verificare HTTP method corretto (GET/POST/PUT/PATCH/DELETE)
‚ñ° Verificare header Content-Type: application/json per POST/PUT/PATCH
‚ñ° Verificare campi obbligatori presenti (es: TerminalID)
‚ñ° Controllare HTTP status code risposta
‚ñ° Leggere body risposta errore per dettagli
‚ñ° Verificare connettivit√† rete/firewall
‚ñ° Testare con curl prima di implementare in codice


================================================================================
11. CONTATTI E SUPPORTO
================================================================================

Per problemi, domande o richieste di supporto:

‚Ä¢ Documentazione: Questo documento
‚Ä¢ Test API: Usa script di test forniti
‚Ä¢ Report bug: Contatta amministratore sistema

VERSIONE API: Verificare con team sviluppo
ULTIMI AGGIORNAMENTI: 2025-11-12


================================================================================
APPENDICE A: QUICK REFERENCE
================================================================================

GET    /stores                 Lista paginata (page, page_size)
GET    /stores/{ID}            Dettaglio singolo
POST   /stores                 Crea nuovo (body JSON)
PUT    /stores/{ID}            Update completo (tutti campi)
PATCH  /stores/{ID}            Update parziale (solo campi modificati)
DELETE /stores/{ID}            Elimina

AUTH: Basic moneynet:demo123
CONTENT-TYPE: application/json
RESPONSE: application/json

200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized,
404 Not Found, 500 Internal Server Error


================================================================================
APPENDICE B: COMANDI CURL RAPIDI
================================================================================

# Lista store
curl -k -u moneynet:demo123 "https://api.payglobe.it/merchant/api/stores?page=1&page_size=10"

# Singolo store
curl -k -u moneynet:demo123 https://api.payglobe.it/merchant/api/stores/12996649

# Crea store
curl -k -u moneynet:demo123 -X POST \
  -H "Content-Type: application/json" \
  -d '{"TerminalID":"999999","Insegna":"Test","country":"IT"}' \
  https://api.payglobe.it/merchant/api/stores

# Aggiorna campo
curl -k -u moneynet:demo123 -X PATCH \
  -H "Content-Type: application/json" \
  -d '{"Insegna":"Nuovo Nome"}' \
  https://api.payglobe.it/merchant/api/stores/999999

# Elimina
curl -k -u moneynet:demo123 -X DELETE \
  https://api.payglobe.it/merchant/api/stores/999999


================================================================================
FINE DOCUMENTAZIONE
================================================================================
